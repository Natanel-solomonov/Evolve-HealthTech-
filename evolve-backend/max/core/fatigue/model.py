import math
from dataclasses import dataclass, field
from typing import Dict

@dataclass
class FatigueModelConfig:
    """
    Configuration for the TwoCompartmentFatigueModel.
    
    Holds all physical and physiological constants, allowing for easy tuning
    and management of model parameters.
    """
    BETA: float = 1.2  # Exponent for intensity in impulse calculation.
    GAMMA: float = 1.0  # Exponent for volume in impulse calculation.
    KAPPA: float = 0.1  # Factor scaling total impulse to central fatigue.

    # Metabolic time constants (hours) per muscle group.
    TAU_MET_HOURS: Dict[str, float] = field(default_factory=lambda: {
        'quadriceps': 33 / 3600,
        'abdominals': 30 / 3600,
        'abductors': 30 / 3600,
        'adductors': 30 / 3600,
        'biceps': 33 / 3600,
        'calves': 26.7 / 3600,
        'cardiovascular': 30 / 3600,
        'chest': 33 / 3600,
        'forearms': 34 / 3600,
        'full body': 30 / 3600,
        'glutes': 40 / 3600,
        'hamstrings': 33 / 3600,
        'lats': 35 / 3600,
        'lower back': 35 / 3600,
        'middle back': 35 / 3600,
        'neck': 25 / 3600,
        'shoulders': 32 / 3600,
        'traps': 35 / 3600,
        'triceps': 33 / 3600
    })
    
    # Central time constants (hours) per muscle group.
    TAU_CEN_HOURS: Dict[str, float] = field(default_factory=lambda: {
        'quadriceps': 48,
        'abdominals': 36,
        'abductors': 48,
        'adductors': 48,
        'biceps': 36,
        'calves': 36,
        'cardiovascular': 24,
        'chest': 48,
        'forearms': 36,
        'full body': 72,
        'glutes': 60,
        'hamstrings': 54,
        'lats': 48,
        'lower back': 48,
        'middle back': 48,
        'neck': 24,
        'shoulders': 48,
        'traps': 48,
        'triceps': 36
    })

class TwoCompartmentFatigueModel:
    """
    Models muscular fatigue using a two-compartment system (metabolic and central)
    to estimate recovery times between sets and after workouts.

    The model's behavior is defined by a `FatigueModelConfig` object, which
    separates the model's parameters from its operational logic.
    """
    
    def __init__(self, config: FatigueModelConfig = None):
        """
        Initializes the fatigue model with a given configuration.
        
        Args:
            config (FatigueModelConfig, optional): A configuration object containing
                model parameters. If None, a default configuration is used.
        """
        self.config = config or FatigueModelConfig()
        self.F_met = {m: 0.0 for m in self.config.TAU_MET_HOURS}
        self.F_cen = {m: 0.0 for m in self.config.TAU_CEN_HOURS}

    def alpha(self, R1: float) -> float:
        """Calculates the alpha factor based on 1 Rep Max (R1)."""
        if R1 <= 0:
            return 1.0 
        return R1 ** (-self.config.GAMMA)

    def compute_impulse(self, sets: int, reps: int, weight: float, R1: float, difficulty_multiplier: float) -> float:
        """
        Computes the fatigue impulse generated by an exercise.

        Args:
            sets (int): Number of sets.
            reps (int): Number of repetitions per set.
            weight (float): Weight lifted.
            R1 (float): 1 Rep Max for the exercise.
            difficulty_multiplier (float): Multiplier to adjust impulse based on exercise difficulty.

        Returns:
            float: The calculated fatigue impulse. Returns 0 if R1 is not positive.
        """
        if R1 <= 0:
            print(f"Warning: R1 is {R1}, which is not positive. Impulse will be 0.")
            return 0.0
        I = weight / R1 # Relative intensity
        V = sets * reps * weight # Volume
        alpha_val = self.alpha(R1)
        return alpha_val * (I ** self.config.BETA) * (V ** self.config.GAMMA) * difficulty_multiplier

    def update_metabolic_fatigue_for_set(self, muscle, reps, weight, R1, difficulty_multiplier, delta_t_hours_before_set):
        """
        Updates the metabolic fatigue for a given muscle after performing a single set.

        Args:
            muscle (str): The primary muscle worked.
            reps (int): Repetitions performed in the set.
            weight (float): Weight used for the set.
            R1 (float): 1 Rep Max for the exercise.
            difficulty_multiplier (float): Difficulty multiplier for the exercise.
            delta_t_hours_before_set (float): Time in hours since the last metabolic activity/update
                                              for this muscle group before this set was performed.

        Returns:
            float: The new metabolic fatigue level for the muscle (capped at 1.0).
        """
        if muscle not in self.config.TAU_MET_HOURS:
            print(f"Warning: Muscle '{muscle}' not found in TAU_MET_HOURS. Skipping metabolic update.")
            return self.F_met.get(muscle, 0.0)

        tau_met = self.config.TAU_MET_HOURS[muscle]
        decay_met = math.exp(-delta_t_hours_before_set / tau_met)
        
        # Impulse is for a single set
        u_met = self.compute_impulse(sets=1, reps=reps, weight=weight, R1=R1, difficulty_multiplier=difficulty_multiplier)
        
        F_prev = self.F_met.get(muscle, 0.0) # Use .get for safety, though __init__ ensures keys
        F_new = decay_met * F_prev + u_met
        self.F_met[muscle] = min(F_new, 1.0)
        return self.F_met[muscle]

    def get_metabolic_rest_time(self, muscle, F_target_met, current_F_met=None):
        """
        Calculates the time required for metabolic fatigue to recover to a target level.

        Args:
            muscle (str): The muscle group.
            F_target_met (float): The target metabolic fatigue level to recover to.
            current_F_met (float, optional): The current metabolic fatigue.
                                             If None, uses the model's stored F_met for the muscle.

        Returns:
            float: Estimated rest time in hours. Returns 0 if current fatigue is already at or below target.
        """
        if muscle not in self.config.TAU_MET_HOURS:
            print(f"Warning: Muscle '{muscle}' not found in TAU_MET_HOURS. Cannot calculate metabolic rest time.")
            return 0.0

        F_cur = current_F_met if current_F_met is not None else self.F_met.get(muscle, 0.0)
        tau_met = self.config.TAU_MET_HOURS[muscle]

        if F_cur <= F_target_met:
            return 0.0
        if F_target_met <= 0: # Avoid math.log(0) or negative
            return float('inf') # Or handle as an error / very long time
        return -tau_met * math.log(F_target_met / F_cur)

    def calculate_intraset_recovery_time(self, muscle, reps, weight, R1, difficulty_multiplier, F_target_met, delta_t_hours_before_set):
        """
        Calculates the ideal intraset recovery time after performing a single set of an exercise.
        This method first updates the model's metabolic fatigue for the muscle based on the set performed
        (after accounting for decay over delta_t_hours_before_set),
        then calculates the time required to recover to F_target_met from this new state.

        Args:
            muscle (str): The primary muscle worked by the set.
            reps (int): Repetitions performed in the set.
            weight (float): Weight used for the set.
            R1 (float): 1 Rep Max for the exercise.
            difficulty_multiplier (float): Difficulty multiplier for the exercise.
            F_target_met (float): The target metabolic fatigue level to recover to.
            delta_t_hours_before_set (float): Time in hours since the last metabolic activity/update
                                              for this muscle group before this set was performed.
        Returns:
            float: Ideal intraset recovery time in hours.
        """
        # Update metabolic fatigue based on the set just performed.
        self.update_metabolic_fatigue_for_set(muscle, reps, weight, R1, difficulty_multiplier, delta_t_hours_before_set)
        
        # Now calculate rest time needed to reach F_target_met from the new fatigue state
        recovery_time_hours = self.get_metabolic_rest_time(muscle, F_target_met)
        return recovery_time_hours

    def _calculate_workout_impulses(self, workout_exercises_details, secondary_muscle_impulse_factor=0.5):
        """
        Calculates the total impulse per muscle group from a list of exercises in a workout.
        Helper method for central fatigue calculations.

        Args:
            workout_exercises_details (list): A list of exercise dictionaries.
                Each dict should contain: 'name', 'sets', 'reps', 'weight', 'R1',
                'primary_muscles' (list[str]), 'secondary_muscles' (list[str]),
                and 'difficulty_multiplier'.
            secondary_muscle_impulse_factor (float): Factor for impulse on secondary muscles.

        Returns:
            dict: A dictionary mapping muscle names (str) to total calculated impulse (float).
        """
        workout_impulses = {m: 0.0 for m in self.config.TAU_CEN_HOURS}

        for ex_detail in workout_exercises_details:
            if ex_detail.get('weight') is None or ex_detail.get('R1') is None or ex_detail['R1'] <=0:
                print(f"Warning: Skipping impulse calculation for '{ex_detail.get('name', 'Unnamed Exercise')}' due to missing or invalid weight/R1.")
                continue

            impulse = self.compute_impulse(
                sets=ex_detail['sets'],
                reps=ex_detail['reps'],
                weight=ex_detail['weight'],
                R1=ex_detail['R1'],
                difficulty_multiplier=ex_detail['difficulty_multiplier']
            )

            for muscle in ex_detail.get('primary_muscles', []):
                if muscle in workout_impulses:
                    workout_impulses[muscle] += impulse
                else:
                    print(f"Warning: Primary muscle '{muscle}' for exercise '{ex_detail.get('name', 'Unnamed Exercise')}' not in TAU_CEN_HOURS. Skipping.")
            
            for muscle in ex_detail.get('secondary_muscles', []):
                if muscle in workout_impulses:
                    workout_impulses[muscle] += impulse * secondary_muscle_impulse_factor
                else:
                    print(f"Warning: Secondary muscle '{muscle}' for exercise '{ex_detail.get('name', 'Unnamed Exercise')}' not in TAU_CEN_HOURS. Skipping.")
        return workout_impulses

    def update_central_fatigue_from_workout(self, workout_exercises_details, delta_t_hours_session, secondary_muscle_impulse_factor=0.5):
        """
        Updates the model's central fatigue state based on a completed workout.

        Args:
            workout_exercises_details (list): List of exercise dictionaries detailing the workout.
                (See _calculate_workout_impulses for dict structure).
            delta_t_hours_session (float): Time in hours since the last central fatigue update
                                           (e.g., time since the end of the previous workout).
            secondary_muscle_impulse_factor (float): Factor for impulse on secondary muscles.

        Returns:
            dict: The updated central fatigue levels (F_cen) for all muscles.
        """
        impulses = self._calculate_workout_impulses(workout_exercises_details, secondary_muscle_impulse_factor)
        
        for muscle, u_total in impulses.items():
            if muscle not in self.config.TAU_CEN_HOURS: # Should be caught by _calculate_workout_impulses, but good for safety
                continue

            tau_cen = self.config.TAU_CEN_HOURS[muscle]
            decay_cen = math.exp(-delta_t_hours_session / tau_cen)
            
            F_prev = self.F_cen.get(muscle, 0.0)
            F_new = decay_cen * F_prev + self.config.KAPPA * u_total
            self.F_cen[muscle] = min(F_new, 1.0)
            
        return self.F_cen.copy() # Return a copy to prevent external modification

    def get_central_rest_time(self, muscle, F_target_cen, current_F_cen=None):
        """
        Calculates the time required for central fatigue to recover to a target level.

        Args:
            muscle (str): The muscle group.
            F_target_cen (float): The target central fatigue level.
            current_F_cen (float, optional): The current central fatigue.
                                             If None, uses the model's stored F_cen for the muscle.
        Returns:
            float: Estimated rest time in hours. Returns 0 if current fatigue is already at or below target.
        """
        if muscle not in self.config.TAU_CEN_HOURS:
            print(f"Warning: Muscle '{muscle}' not found in TAU_CEN_HOURS. Cannot calculate central rest time.")
            return 0.0

        F_cur = current_F_cen if current_F_cen is not None else self.F_cen.get(muscle, 0.0)
        tau_cen = self.config.TAU_CEN_HOURS[muscle]

        if F_cur <= F_target_cen:
            return 0.0
        if F_target_cen <= 0: # Avoid math.log(0) or negative
            return float('inf')
        return -tau_cen * math.log(F_target_cen / F_cur)

    def get_projected_central_recovery_times(self, workout_exercises_details, F_target_cen=0.2, secondary_muscle_impulse_factor=0.5, assume_fresh_start=True, initial_F_cen_override=None):
        """
        Calculates projected central recovery times for each muscle group after a given workout.
        This method DOES NOT alter the model's internal F_cen state. It performs a projection.

        Args:
            workout_exercises_details (list): Exercise dictionaries for the workout.
            F_target_cen (float): Target central fatigue level for recovery calculation.
            secondary_muscle_impulse_factor (float): Factor for secondary muscle impulse.
            assume_fresh_start (bool): If True, calculates recovery assuming F_cen starts at 0.0
                                       before this workout's impact.
            initial_F_cen_override (dict, optional): If provided and assume_fresh_start is False,
                                                     this dictionary (muscle: fatigue_level) will be
                                                     used as the starting F_cen for the projection.
                                                     If None and assume_fresh_start is False, the model's
                                                     current F_cen state is used as the starting point.

        Returns:
            dict: Muscle names (str) to projected recovery_time_hours (float).
        """
        if assume_fresh_start:
            starting_F_cen = {m: 0.0 for m in self.config.TAU_CEN_HOURS}
        elif initial_F_cen_override is not None:
            starting_F_cen = {m: initial_F_cen_override.get(m, 0.0) for m in self.config.TAU_CEN_HOURS}
        else:
            starting_F_cen = self.F_cen.copy() # Use current model state if no override

        workout_impulses = self._calculate_workout_impulses(workout_exercises_details, secondary_muscle_impulse_factor)
        
        projected_F_cen_after_workout = {}
        for muscle, u_total in workout_impulses.items():
            if muscle not in self.config.TAU_CEN_HOURS:
                continue
            # For projection, delta_t_hours_session is 0 as we're calculating impact of *this* workout
            # on the `starting_F_cen`. The decay of `starting_F_cen` would have happened *before* this workout.
            F_prev = starting_F_cen.get(muscle, 0.0)
            F_new_after_impulse = F_prev + self.config.KAPPA * u_total # Simplification for projection without decay during session
            projected_F_cen_after_workout[muscle] = min(F_new_after_impulse, 1.0)

        recovery_times = {}
        for muscle in self.config.TAU_CEN_HOURS.keys():
            current_fatigue_for_muscle = projected_F_cen_after_workout.get(muscle, starting_F_cen.get(muscle, 0.0))
            if current_fatigue_for_muscle > 0: # Only calculate if fatigued
                 recovery_times[muscle] = self.get_central_rest_time(muscle, F_target_cen, current_F_cen=current_fatigue_for_muscle)
            else:
                 recovery_times[muscle] = 0.0
        return recovery_times

    def get_central_recovery_curve(self, muscle, hours_to_project=None, F_target_cen_for_max_time=0.01):
        """
        Generates a recovery curve (fatigue level over time) for a specific muscle
        based on its current central fatigue level in the model.

        Args:
            muscle (str): The muscle group to generate the recovery curve for.
            hours_to_project (int, optional): The number of hours to project the recovery.
                                              If None, projects until fatigue is near F_target_cen_for_max_time.
            F_target_cen_for_max_time (float): If hours_to_project is None, this target is used to
                                               determine the maximum projection time. Default is 0.01 (1% fatigue).


        Returns:
            dict: A dictionary where keys are hours (int, starting from 0) and
                  values are the projected central fatigue levels (float) at that hour.
                  Returns an empty dict if the muscle is not found or not fatigued.
        """
        if muscle not in self.config.TAU_CEN_HOURS or muscle not in self.F_cen:
            print(f"Warning: Muscle '{muscle}' not found or not initialized. Cannot generate recovery curve.")
            return {}

        F0 = self.F_cen[muscle]
        if F0 <= 0: # Not fatigued
            return {0: 0.0}

        tau = self.config.TAU_CEN_HOURS[muscle]
        recovery_curve_hourly = {}

        max_time_h = hours_to_project
        if max_time_h is None:
            # Calculate time to reach a very low fatigue level to determine projection range
            # Avoid F_target_cen_for_max_time = 0 to prevent issues with log
            effective_target = max(F_target_cen_for_max_time, 1e-6) # Ensure target is positive
            if F0 > effective_target :
                 max_time_h = int(math.ceil(self.get_central_rest_time(muscle, effective_target, current_F_cen=F0)))
            else:
                 max_time_h = 0 # Already below target

        for hour in range(max_time_h + 1):
            F_hour = F0 * math.exp(-hour / tau)
            recovery_curve_hourly[hour] = F_hour
        
        return recovery_curve_hourly

# --- Main demonstration block ---
if __name__ == "__main__":
    print("--- TwoCompartmentFatigueModel Demonstration ---")

    # To use the model, you can now optionally define a custom config
    # For this demo, we'll use the default config by instantiating without arguments.
    default_config = FatigueModelConfig()
    model = TwoCompartmentFatigueModel(config=default_config)
    
    exercise_difficulty_demo = 1.0
    muscle_demo = 'quadriceps'
    R1_demo = 150
    weight_demo = 100
    reps_demo = 10
    F_target_met_demo = 0.5

    # --- Intra-set Recovery Calculation Demo (Multiple Sets) ---
    print(f"\n--- Intra-set Recovery Simulation for {muscle_demo.capitalize()} ---")
    print(f"Initial F_met[{muscle_demo}]: {model.F_met[muscle_demo]:.3f}")

    # Simulate 3 sets
    # delta_t_between_sets_hours is the time from the END of the previous set's rest
    # to the START of the current set's work.
    # For the first set, we can assume it's effectively 0 or some long time has passed.
    # Let's assume this delta_t_hours_before_set accounts for any rest taken *plus* prior activity decay.

    delta_t_since_last_activity_hours = 0.033 # Approx 2 mins, as an example of time before the first set
                                            # or time passed since some other unrelated activity for this muscle.
                                            # For subsequent sets, this would be the actual rest time taken.
    
    for i in range(1, 4):
        print(f"\nSet {i}:")
        # Decay existing fatigue before this set (if any)
        # F_met_before_decay_calc = model.F_met[muscle_demo]
        # decayed_F_met_before_set = F_met_before_decay_calc * math.exp(-delta_t_since_last_activity_hours / model.config.TAU_MET_HOURS[muscle_demo])
        # print(f"  F_met[{muscle_demo}] before this set (after decay from {F_met_before_decay_calc:.3f} over {delta_t_since_last_activity_hours*60:.1f} min): {decayed_F_met_before_set:.3f}")

        # The `calculate_intraset_recovery_time` method handles the decay internally via `delta_t_hours_before_set`
        # and then adds the new impulse.
        
        # Let's capture F_met *before* the update within calculate_intraset_recovery_time to show its state.
        # This requires knowing tau_met for the muscle.
        tau_met_muscle = model.config.TAU_MET_HOURS[muscle_demo]
        F_met_at_start_of_set_excl_impulse = model.F_met[muscle_demo] * math.exp(-delta_t_since_last_activity_hours / tau_met_muscle)

        recommended_rest_hours = model.calculate_intraset_recovery_time(
            muscle=muscle_demo,
            reps=reps_demo,
            weight=weight_demo,
            R1=R1_demo,
            difficulty_multiplier=exercise_difficulty_demo,
            F_target_met=F_target_met_demo,
            delta_t_hours_before_set=delta_t_since_last_activity_hours # Time *before* this set's impulse is applied
        )
        
        F_met_after_set_and_update = model.F_met[muscle_demo] # F_met is now updated
        print(f"  F_met[{muscle_demo}] just before set (after decay): {F_met_at_start_of_set_excl_impulse:.3f}")
        print(f"  F_met[{muscle_demo}] after set (impulse added): {F_met_after_set_and_update:.3f}")
        print(f"  Recommended rest to reach F_met={F_target_met_demo:.2f}: {recommended_rest_hours * 60:.1f} minutes.")

        # For the next iteration, delta_t_since_last_activity_hours would be the recommended_rest_hours
        # (or actual rest taken by user). For simplicity, we'll reuse a fixed value.
        delta_t_since_last_activity_hours = recommended_rest_hours # or fixed 0.033 if simulating fixed rest
        if recommended_rest_hours == 0 and F_met_after_set_and_update > F_target_met_demo :
             # if rest is 0 but still fatigued, means target is too high or impulse too low.
             # for demo, let's ensure some time passes to see decay.
             delta_t_since_last_activity_hours = 0.01 # ~30 seconds for demo progression

    # --- Central Fatigue Update and Recovery Projection Demo ---
    print("\n--- Central Fatigue and Recovery Projection ---")
    
    # Reset model F_cen for a clean workout calculation demonstration
    model.F_cen = {m: 0.0 for m in model.config.TAU_CEN_HOURS}
    print(f"Initial F_cen for all muscles (before workout): 0.0")

    sample_workout_exercises = [
        {
            'name': 'Bench Press', 'sets': 3, 'reps': 8, 'weight': 80, 'R1': 100,
            'primary_muscles': ['chest', 'triceps'], 'secondary_muscles': ['shoulders'],
            'difficulty_multiplier': 1.0
        },
        {
            'name': 'Squats', 'sets': 4, 'reps': 10, 'weight': 100, 'R1': 130,
            'primary_muscles': ['quadriceps', 'glutes'], 'secondary_muscles': ['hamstrings', 'lower back'],
            'difficulty_multiplier': 1.1
        },
        {
            'name': 'Bicep Curls (Light)', 'sets': 3, 'reps': 12, 'weight': 15, 'R1': 25, # Lower R1 implies it's perceived harder for this weight if R1 means max possible lift
            'primary_muscles': ['biceps'], 'secondary_muscles': ['forearms'],
            'difficulty_multiplier': 0.9
        }
    ]

    # 1. Update the model's actual central fatigue state after this workout
    # Assume this workout happens 48 hours after the last impactful activity for central fatigue
    delta_t_session_hours = 48 
    updated_F_cen_actual = model.update_central_fatigue_from_workout(
        sample_workout_exercises,
        delta_t_hours_session=delta_t_session_hours, # Time since last central update
        secondary_muscle_impulse_factor=0.5
    )
    print(f"\nModel's F_cen after workout (decayed over {delta_t_session_hours}h then new impulses added):")
    for m, f in updated_F_cen_actual.items():
        if f > 0.01 : print(f"  - {m.capitalize()}: {f:.3f}")


    # 2. Get projected recovery times (e.g., if this workout was done from a fresh state)
    # This does NOT change model.F_cen
    projected_times_fresh_start = model.get_projected_central_recovery_times(
        sample_workout_exercises,
        F_target_cen=0.2,
        assume_fresh_start=True
    )
    print("\nProjected Central Recovery Times (if workout done from F_cen=0, to F_target=0.2):")
    for muscle, time_h in projected_times_fresh_start.items():
        if time_h > 0:
            print(f"- {muscle.capitalize()}: {time_h:.1f} hours")

    # 3. Get recovery curve for a specific muscle based on the model's *current* F_cen state
    target_muscle_for_curve = 'chest'
    print(f"\nGenerating recovery curve for {target_muscle_for_curve.capitalize()} from its current F_cen ({model.F_cen.get(target_muscle_for_curve, 0):.3f}):")
    
    recovery_curve = model.get_central_recovery_curve(target_muscle_for_curve, hours_to_project=None, F_target_cen_for_max_time=0.05) # project until 5%
    if recovery_curve:
        # Sort by hour for printing, though dict may not preserve order for very old Pythons
        for hour in sorted(recovery_curve.keys()):
            if hour % 6 == 0 or hour == 0 or hour == max(recovery_curve.keys()): # Print every 6 hours + first and last
                 print(f"  Hour {hour}: F_cen = {recovery_curve[hour]:.3f}")
    else:
        print(f"  No recovery curve generated for {target_muscle_for_curve.capitalize()} (maybe not fatigued or muscle not found).")

    # Example: project recovery from a custom initial state (not affecting the main model instance)
    custom_initial_F_cen = {'chest': 0.8, 'quadriceps': 0.7, 'biceps': 0.3} # Example high fatigue
    projected_times_custom_start = model.get_projected_central_recovery_times(
        sample_workout_exercises,
        F_target_cen=0.2,
        assume_fresh_start=False,
        initial_F_cen_override=custom_initial_F_cen
    )
    print(f"\nProjected Central Recovery Times (if workout done from custom F_cen, to F_target=0.2):")
    print(f"  (Starting from custom F_cen like Chest: {custom_initial_F_cen.get('chest',0)}, etc.)")
    for muscle, time_h in projected_times_custom_start.items():
        if time_h > 0:
            print(f"- {muscle.capitalize()}: {time_h:.1f} hours")
    
    print("\n--- Demonstration Complete ---")